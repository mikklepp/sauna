import { NextRequest } from 'next/server';
import { requireClubAuth, requireAdminAuth } from '@/lib/auth';
import { 
  parseRequestBody, 
  successResponse, 
  errorResponse, 
  handleApiError,
  getQueryParam 
} from '@/lib/api-utils';
import { createSharedReservationSchema } from '@/lib/validation';
import prisma from '@/lib/db';
import { startOfDay, endOfDay } from 'date-fns';

/**
 * POST /api/shared-reservations
 * Create a new shared reservation (admin only)
 */
export async function POST(request: NextRequest) {
  try {
    await requireAdminAuth(); // Only admins can create shared reservations
    const body = await parseRequestBody(request);
    
    // Validate input
    const validated = createSharedReservationSchema.parse(body);
    
    // Check if sauna exists
    const sauna = await prisma.sauna.findUnique({
      where: { id: validated.saunaId },
    });
    
    if (!sauna) {
      return errorResponse('Sauna not found', 404);
    }
    
    // Create shared reservation
    const sharedReservation = await prisma.sharedReservation.create({
      data: {
        saunaId: validated.saunaId,
        date: validated.date,
        startTime: validated.startTime,
        malesDurationHours: validated.malesDurationHours,
        femalesDurationHours: validated.femalesDurationHours,
        genderOrder: validated.genderOrder,
        name: validated.name,
        description: validated.description,
        isAutoGenerated: false,
        createdBy: 'admin',
      },
      include: {
        sauna: true,
      },
    });
    
    return successResponse(sharedReservation, 201);
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * GET /api/shared-reservations?saunaId=xxx&date=xxx
 * Get shared reservations (admin gets all, club users get for specific sauna)
 */
export async function GET(request: NextRequest) {
  try {
    // Try admin auth first
    try {
      await requireAdminAuth();

      // Admin users get all shared reservations
      const saunaId = getQueryParam(request, 'saunaId');
      const dateStr = getQueryParam(request, 'date');

      const where: any = {};

      if (saunaId) {
        where.saunaId = saunaId;
      }

      if (dateStr) {
        const date = new Date(dateStr);
        const dayStart = startOfDay(date);
        const dayEnd = endOfDay(date);
        where.date = {
          gte: dayStart,
          lte: dayEnd,
        };
      }

      const sharedReservations = await prisma.sharedReservation.findMany({
        where,
        include: {
          sauna: {
            include: {
              island: {
                include: {
                  club: {
                    select: {
                      name: true,
                    },
                  },
                },
              },
            },
          },
          participants: {
            include: {
              boat: true,
            },
          },
          _count: {
            select: {
              participants: true,
            },
          },
        },
        orderBy: {
          date: 'desc',
        },
      });

      return successResponse(sharedReservations);
    } catch {
      // Fall back to club auth
      const club = await requireClubAuth();

      const saunaId = getQueryParam(request, 'saunaId');
      const dateStr = getQueryParam(request, 'date');

      if (!saunaId) {
        return errorResponse('saunaId query parameter is required', 400);
      }

      // Check if sauna belongs to club
      const sauna = await prisma.sauna.findUnique({
        where: { id: saunaId },
        include: { island: true },
      });

      if (!sauna || sauna.island.clubId !== club.id) {
        return errorResponse('Sauna not found', 404);
      }

      // Parse date or use today
      const date = dateStr ? new Date(dateStr) : new Date();
      const dayStart = startOfDay(date);
      const dayEnd = endOfDay(date);

      // Get shared reservations
      const sharedReservations = await prisma.sharedReservation.findMany({
        where: {
          saunaId,
          date: {
            gte: dayStart,
            lte: dayEnd,
          },
        },
        include: {
          participants: {
            include: {
              boat: true,
            },
          },
          _count: {
            select: {
              participants: true,
            },
          },
        },
        orderBy: {
          startTime: 'asc',
        },
      });

      return successResponse(sharedReservations);
    }
  } catch (error) {
    return handleApiError(error);
  }
}