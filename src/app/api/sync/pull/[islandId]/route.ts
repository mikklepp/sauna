import { NextRequest } from 'next/server';
import {
  successResponse,
  errorResponse,
  handleApiError,
  getPathParam,
  getQueryParam,
} from '@/lib/api-utils';
import prisma from '@/lib/db';
import { startOfDay } from 'date-fns';

/**
 * GET /api/sync/pull/[islandId]?since=timestamp
 * Pull changes from backend to Island Device
 *
 * This allows user-created reservations (via web app) to sync TO the Island Device
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { islandId: string } }
) {
  try {
    const islandId = getPathParam(params, 'islandId');
    const sinceParam = getQueryParam(request, 'since');

    // Verify island exists
    const island = await prisma.island.findUnique({
      where: { id: islandId },
      include: {
        saunas: true,
      },
    });

    if (!island) {
      return errorResponse('Island not found', 404);
    }

    const since = sinceParam ? new Date(sinceParam) : startOfDay(new Date());
    const saunaIds = island.saunas.map((s) => s.id);

    // Get reservations created/modified since timestamp
    const reservations = await prisma.reservation.findMany({
      where: {
        saunaId: {
          in: saunaIds,
        },
        OR: [{ createdAt: { gte: since } }, { updatedAt: { gte: since } }],
      },
      orderBy: {
        createdAt: 'asc',
      },
    });

    // Get shared reservations
    const sharedReservations = await prisma.sharedReservation.findMany({
      where: {
        saunaId: {
          in: saunaIds,
        },
        OR: [{ createdAt: { gte: since } }, { updatedAt: { gte: since } }],
      },
      include: {
        participants: true,
      },
      orderBy: {
        createdAt: 'asc',
      },
    });

    // Format as sync changes
    const changes = [
      ...reservations.map((r) => ({
        id: crypto.randomUUID(),
        entityType: 'reservation' as const,
        entityId: r.id,
        operation: 'create' as const,
        data: {
          id: r.id,
          saunaId: r.saunaId,
          boatId: r.boatId,
          startTime: r.startTime.toISOString(),
          endTime: r.endTime.toISOString(),
          adults: r.adults,
          kids: r.kids,
          status: r.status,
          createdAt: r.createdAt.toISOString(),
          cancelledAt: r.cancelledAt?.toISOString() || null,
        },
        timestamp: r.updatedAt,
      })),
      ...sharedReservations.flatMap((sr) => [
        {
          id: crypto.randomUUID(),
          entityType: 'shared_reservation' as const,
          entityId: sr.id,
          operation: 'create' as const,
          data: {
            id: sr.id,
            saunaId: sr.saunaId,
            date: sr.date.toISOString().split('T')[0],
            startTime: sr.startTime.toISOString(),
            malesDurationHours: sr.malesDurationHours,
            femalesDurationHours: sr.femalesDurationHours,
            genderOrder: sr.genderOrder,
            name: sr.name,
            description: sr.description,
            isAutoGenerated: sr.isAutoGenerated,
            autoCancelledAt: sr.autoCancelledAt?.toISOString() || null,
            convertedToIndividual: sr.convertedToIndividual,
          },
          timestamp: sr.updatedAt,
        },
        ...sr.participants.map((p) => ({
          id: crypto.randomUUID(),
          entityType: 'shared_participant' as const,
          entityId: p.id,
          operation: 'create' as const,
          data: {
            id: p.id,
            sharedReservationId: p.sharedReservationId,
            boatId: p.boatId,
            adults: p.adults,
            kids: p.kids,
            joinedAt: p.joinedAt.toISOString(),
          },
          timestamp: p.joinedAt,
        })),
      ]),
    ];

    return successResponse({
      islandId,
      changes,
      timestamp: new Date(),
    });
  } catch (error) {
    return handleApiError(error);
  }
}
