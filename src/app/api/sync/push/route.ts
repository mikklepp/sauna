import { NextRequest } from 'next/server';
import { parseRequestBody, successResponse, errorResponse, handleApiError } from '@/lib/api-utils';
import prisma from '@/lib/db';
import type { SyncRequest, SyncResponse, SyncChange } from '@/types';

/**
 * POST /api/sync/push
 * Push changes from Island Device to backend
 * 
 * Island Device is the source of truth, so these changes are authoritative
 */
export async function POST(request: NextRequest) {
  try {
    const body = await parseRequestBody<SyncRequest>(request);
    
    if (!body.islandId || !Array.isArray(body.changes)) {
      return errorResponse('Invalid sync request format', 400);
    }
    
    // Verify island exists
    const island = await prisma.island.findUnique({
      where: { id: body.islandId },
    });
    
    if (!island) {
      return errorResponse('Island not found', 404);
    }
    
    const appliedChanges: string[] = [];
    const rejectedChanges: Array<{ id: string; reason: string }> = [];
    
    // Process each change
    for (const change of body.changes) {
      try {
        switch (change.entityType) {
          case 'reservation':
            await handleReservationSync(change);
            appliedChanges.push(change.id);
            break;
            
          case 'shared_reservation':
            await handleSharedReservationSync(change);
            appliedChanges.push(change.id);
            break;
            
          case 'shared_participant':
            await handleSharedParticipantSync(change);
            appliedChanges.push(change.id);
            break;
            
          default:
            rejectedChanges.push({
              id: change.id,
              reason: `Unknown entity type: ${change.entityType}`,
            });
        }
      } catch (error) {
        console.error(`Error processing change ${change.id}:`, error);
        rejectedChanges.push({
          id: change.id,
          reason: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    }
    
    // Log sync activity
    await prisma.syncLog.createMany({
      data: appliedChanges.map(changeId => {
        const change = body.changes.find(c => c.id === changeId)!;
        return {
          islandId: body.islandId,
          entityType: change.entityType,
          entityId: change.entityId,
          operation: change.operation,
          dataSnapshot: change.data,
          status: 'SYNCED',
        };
      }),
    });
    
    const response: SyncResponse = {
      success: true,
      appliedChanges,
      rejectedChanges,
      serverChanges: [], // No server changes to push back for now
      newSyncTimestamp: new Date(),
    };
    
    return successResponse(response);
  } catch (error) {
    return handleApiError(error);
  }
}

async function handleReservationSync(change: SyncChange) {
  const data = change.data;
  
  switch (change.operation) {
    case 'create':
      await prisma.reservation.upsert({
        where: { id: change.entityId },
        create: {
          id: change.entityId,
          saunaId: data.saunaId,
          boatId: data.boatId,
          startTime: new Date(data.startTime),
          endTime: new Date(data.endTime),
          adults: data.adults,
          kids: data.kids,
          status: data.status,
          createdAt: new Date(data.createdAt),
          cancelledAt: data.cancelledAt ? new Date(data.cancelledAt) : null,
        },
        update: {
          status: data.status,
          cancelledAt: data.cancelledAt ? new Date(data.cancelledAt) : null,
        },
      });
      break;
      
    case 'update':
      await prisma.reservation.update({
        where: { id: change.entityId },
        data: {
          status: data.status,
          cancelledAt: data.cancelledAt ? new Date(data.cancelledAt) : null,
        },
      });
      break;
      
    case 'delete':
      await prisma.reservation.delete({
        where: { id: change.entityId },
      });
      break;
  }
}

async function handleSharedReservationSync(change: SyncChange) {
  const data = change.data;
  
  switch (change.operation) {
    case 'create':
      await prisma.sharedReservation.upsert({
        where: { id: change.entityId },
        create: {
          id: change.entityId,
          saunaId: data.saunaId,
          date: new Date(data.date),
          startTime: new Date(data.startTime),
          malesDurationHours: data.malesDurationHours,
          femalesDurationHours: data.femalesDurationHours,
          genderOrder: data.genderOrder,
          name: data.name,
          description: data.description,
          isAutoGenerated: data.isAutoGenerated,
          autoCancelledAt: data.autoCancelledAt ? new Date(data.autoCancelledAt) : null,
          convertedToIndividual: data.convertedToIndividual,
          createdBy: 'island_device',
        },
        update: {
          autoCancelledAt: data.autoCancelledAt ? new Date(data.autoCancelledAt) : null,
          convertedToIndividual: data.convertedToIndividual,
        },
      });
      break;
      
    case 'update':
      await prisma.sharedReservation.update({
        where: { id: change.entityId },
        data: {
          autoCancelledAt: data.autoCancelledAt ? new Date(data.autoCancelledAt) : null,
          convertedToIndividual: data.convertedToIndividual,
        },
      });
      break;
      
    case 'delete':
      await prisma.sharedReservation.delete({
        where: { id: change.entityId },
      });
      break;
  }
}

async function handleSharedParticipantSync(change: SyncChange) {
  const data = change.data;
  
  switch (change.operation) {
    case 'create':
      await prisma.sharedReservationParticipant.upsert({
        where: { id: change.entityId },
        create: {
          id: change.entityId,
          sharedReservationId: data.sharedReservationId,
          boatId: data.boatId,
          adults: data.adults,
          kids: data.kids,
          joinedAt: new Date(data.joinedAt),
        },
        update: {
          adults: data.adults,
          kids: data.kids,
        },
      });
      break;
      
    case 'update':
      await prisma.sharedReservationParticipant.update({
        where: { id: change.entityId },
        data: {
          adults: data.adults,
          kids: data.kids,
        },
      });
      break;
      
    case 'delete':
      await prisma.sharedReservationParticipant.delete({
        where: { id: change.entityId },
      });
      break;
  }
}