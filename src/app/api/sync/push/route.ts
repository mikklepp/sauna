import { NextRequest } from 'next/server';
import {
  parseRequestBody,
  successResponse,
  errorResponse,
  handleApiError,
} from '@/lib/api-utils';
import prisma from '@/lib/db';
import type { SyncRequest, SyncResponse, SyncChange } from '@/types';
import { ReservationStatus, GenderOrder } from '@prisma/client';

/**
 * POST /api/sync/push
 * Push changes from Island Device to backend
 *
 * Island Device is the source of truth, so these changes are authoritative
 */
export async function POST(request: NextRequest) {
  try {
    const body = await parseRequestBody<SyncRequest>(request);

    if (!body.islandId || !Array.isArray(body.changes)) {
      return errorResponse('Invalid sync request format', 400);
    }

    // Verify island exists
    const island = await prisma.island.findUnique({
      where: { id: body.islandId },
    });

    if (!island) {
      return errorResponse('Island not found', 404);
    }

    const appliedChanges: string[] = [];
    const rejectedChanges: Array<{ id: string; reason: string }> = [];

    // Process each change
    for (const change of body.changes) {
      try {
        switch (change.entityType) {
          case 'reservation':
            await handleReservationSync(change);
            appliedChanges.push(change.id);
            break;

          case 'shared_reservation':
            await handleSharedReservationSync(change);
            appliedChanges.push(change.id);
            break;

          case 'shared_participant':
            await handleSharedParticipantSync(change);
            appliedChanges.push(change.id);
            break;

          default:
            rejectedChanges.push({
              id: change.id,
              reason: `Unknown entity type: ${change.entityType}`,
            });
        }
      } catch (error) {
        console.error(`Error processing change ${change.id}:`, error);
        rejectedChanges.push({
          id: change.id,
          reason: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    }

    // Log sync activity
    await prisma.syncLog.createMany({
      data: appliedChanges.map((changeId) => {
        const change = body.changes.find((c) => c.id === changeId)!;
        return {
          islandId: body.islandId,
          entityType: change.entityType,
          entityId: change.entityId,
          operation: change.operation,
          dataSnapshot: change.data as never,
          status: 'SYNCED',
        };
      }),
    });

    const response: SyncResponse = {
      success: true,
      appliedChanges,
      rejectedChanges,
      serverChanges: [], // No server changes to push back for now
      newSyncTimestamp: new Date(),
    };

    return successResponse(response);
  } catch (error) {
    return handleApiError(error);
  }
}

async function handleReservationSync(change: SyncChange) {
  const data = change.data;

  switch (change.operation) {
    case 'create':
      await prisma.reservation.upsert({
        where: { id: change.entityId },
        create: {
          id: change.entityId,
          saunaId: data.saunaId as string,
          boatId: data.boatId as string,
          startTime: new Date(data.startTime as string),
          endTime: new Date(data.endTime as string),
          adults: data.adults as number,
          kids: data.kids as number,
          status: data.status as ReservationStatus,
          createdAt: new Date(data.createdAt as string),
          cancelledAt: data.cancelledAt
            ? new Date(data.cancelledAt as string)
            : null,
        },
        update: {
          status: data.status as ReservationStatus,
          cancelledAt: data.cancelledAt
            ? new Date(data.cancelledAt as string)
            : null,
        },
      });
      break;

    case 'update':
      await prisma.reservation.update({
        where: { id: change.entityId },
        data: {
          status: data.status as ReservationStatus,
          cancelledAt: data.cancelledAt
            ? new Date(data.cancelledAt as string)
            : null,
        },
      });
      break;

    case 'delete':
      await prisma.reservation.delete({
        where: { id: change.entityId },
      });
      break;
  }
}

async function handleSharedReservationSync(change: SyncChange) {
  const data = change.data;

  switch (change.operation) {
    case 'create':
      await prisma.sharedReservation.upsert({
        where: { id: change.entityId },
        create: {
          id: change.entityId,
          saunaId: data.saunaId as string,
          date: new Date(data.date as string),
          startTime: new Date(data.startTime as string),
          malesDurationHours: data.malesDurationHours as number,
          femalesDurationHours: data.femalesDurationHours as number,
          genderOrder: data.genderOrder as GenderOrder,
          name: data.name as string,
          description: data.description as string | null | undefined,
          isAutoGenerated: data.isAutoGenerated as boolean,
          autoCancelledAt: data.autoCancelledAt
            ? new Date(data.autoCancelledAt as string)
            : null,
          convertedToIndividual: data.convertedToIndividual as boolean,
          createdBy: 'island_device',
        },
        update: {
          autoCancelledAt: data.autoCancelledAt
            ? new Date(data.autoCancelledAt as string)
            : null,
          convertedToIndividual: data.convertedToIndividual as boolean,
        },
      });
      break;

    case 'update':
      await prisma.sharedReservation.update({
        where: { id: change.entityId },
        data: {
          autoCancelledAt: data.autoCancelledAt
            ? new Date(data.autoCancelledAt as string)
            : null,
          convertedToIndividual: data.convertedToIndividual as boolean,
        },
      });
      break;

    case 'delete':
      await prisma.sharedReservation.delete({
        where: { id: change.entityId },
      });
      break;
  }
}

async function handleSharedParticipantSync(change: SyncChange) {
  const data = change.data;

  switch (change.operation) {
    case 'create':
      await prisma.sharedReservationParticipant.upsert({
        where: { id: change.entityId },
        create: {
          id: change.entityId,
          sharedReservationId: data.sharedReservationId as string,
          boatId: data.boatId as string,
          adults: data.adults as number,
          kids: data.kids as number,
          joinedAt: new Date(data.joinedAt as string),
        },
        update: {
          adults: data.adults as number,
          kids: data.kids as number,
        },
      });
      break;

    case 'update':
      await prisma.sharedReservationParticipant.update({
        where: { id: change.entityId },
        data: {
          adults: data.adults as number,
          kids: data.kids as number,
        },
      });
      break;

    case 'delete':
      await prisma.sharedReservationParticipant.delete({
        where: { id: change.entityId },
      });
      break;
  }
}
