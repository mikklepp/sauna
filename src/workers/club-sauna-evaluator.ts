/**
 * Club Sauna Evaluator Worker
 *
 * Runs daily at 20:00 (8 PM) local time on Island Device
 *
 * Purpose:
 * - Evaluates today's auto-generated Club Sauna reservations
 * - If < 3 boats registered: Cancel shared reservation and convert participants to individual reservations
 * - If >= 3 boats: Let shared reservation proceed as planned
 *
 * This worker operates COMPLETELY OFFLINE on the Island Device
 */

import { db } from '@/db/schema';
import type { LocalReservation } from '@/types';

const MINIMUM_PARTICIPANTS = 3;

interface EvaluationResult {
  evaluated: number;
  cancelled: number;
  converted: number;
  proceeded: number;
  errors: string[];
}

/**
 * Evaluate and process Club Sauna reservations for today
 */
export async function evaluateClubSaunas(): Promise<EvaluationResult> {
  const result: EvaluationResult = {
    evaluated: 0,
    cancelled: 0,
    converted: 0,
    proceeded: 0,
    errors: [],
  };

  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // eslint-disable-next-line no-console
    console.log('[Club Sauna Evaluator] Starting evaluation for today');

    // Get all auto-generated Club Sauna reservations for today
    const clubSaunas = await db.sharedReservations
      .where('[date+isAutoGenerated]')
      .equals([today.toISOString(), 1])
      .toArray();

    // eslint-disable-next-line no-console
    console.log(
      `[Club Sauna Evaluator] Found ${clubSaunas.length} Club Saunas to evaluate`
    );

    for (const clubSauna of clubSaunas) {
      try {
        result.evaluated++;

        // Get participants
        const participants = await db.sharedParticipants
          .where('sharedReservationId')
          .equals(clubSauna.id)
          .toArray();

        const participantCount = participants.length;

        // eslint-disable-next-line no-console
        console.log(
          `[Club Sauna Evaluator] Club Sauna ${clubSauna.id}: ${participantCount} participants`
        );

        // Decision point: < 3 boats = cancel and convert
        if (participantCount < MINIMUM_PARTICIPANTS) {
          // eslint-disable-next-line no-console
          console.log(
            `[Club Sauna Evaluator] Cancelling (${participantCount} < ${MINIMUM_PARTICIPANTS})`
          );

          // Cancel the shared reservation
          await db.sharedReservations.update(clubSauna.id, {
            autoCancelledAt: new Date().toISOString(),
            syncStatus: 'pending',
          });

          // Add cancellation to sync queue
          await db.syncQueue.add({
            id: crypto.randomUUID(),
            timestamp: new Date(),
            entityType: 'shared_reservation',
            entityId: clubSauna.id,
            operation: 'update',
            data: { autoCancelledAt: new Date().toISOString() },
          });

          result.cancelled++;

          // Convert participants to individual reservations
          for (const participant of participants) {
            try {
              // Get boat info
              const boat = await db.boats.get(participant.boatId);
              if (!boat) {
                throw new Error(`Boat ${participant.boatId} not found`);
              }

              // Get sauna info
              const sauna = await db.saunas.get(clubSauna.saunaId);
              if (!sauna) {
                throw new Error(`Sauna ${clubSauna.saunaId} not found`);
              }

              // Parse start time
              const [hours, minutes] = clubSauna.startTime
                .split(':')
                .map(Number);
              const startTime = new Date(today);
              startTime.setHours(hours, minutes, 0, 0);

              const endTime = new Date(startTime);
              endTime.setHours(startTime.getHours() + 1);

              // Create individual reservation
              const reservation: Partial<LocalReservation> = {
                id: crypto.randomUUID(),
                saunaId: clubSauna.saunaId,
                boatId: participant.boatId,
                startTime: startTime.toISOString(),
                endTime: endTime.toISOString(),
                adults: participant.adults,
                kids: participant.kids,
                status: 'ACTIVE',
                createdAt: new Date().toISOString(),
                syncStatus: 'pending',
              };

              await db.reservations.add(reservation as LocalReservation);

              // Add to sync queue
              await db.syncQueue.add({
                id: crypto.randomUUID(),
                timestamp: new Date(),
                entityType: 'reservation',
                entityId: reservation.id!,
                operation: 'create',
                data: reservation as unknown as Record<string, unknown>,
              });

              // Remove from shared participants
              await db.sharedParticipants.delete(participant.id);

              // eslint-disable-next-line no-console
              console.log(
                `[Club Sauna Evaluator] Converted boat ${boat.name} to individual reservation`
              );
              result.converted++;
            } catch (err) {
              const error = `Failed to convert participant ${participant.id}: ${
                err instanceof Error ? err.message : 'Unknown error'
              }`;
              // eslint-disable-next-line no-console
              console.error(error);
              result.errors.push(error);
            }
          }

          // Mark shared reservation as converted
          await db.sharedReservations.update(clubSauna.id, {
            convertedToIndividual: true,
            syncStatus: 'pending',
          });
        } else {
          // eslint-disable-next-line no-console
          console.log(
            `[Club Sauna Evaluator] Proceeding (${participantCount} >= ${MINIMUM_PARTICIPANTS})`
          );
          result.proceeded++;
        }
      } catch (err) {
        const error = `Failed to evaluate Club Sauna ${clubSauna.id}: ${
          err instanceof Error ? err.message : 'Unknown error'
        }`;
        // eslint-disable-next-line no-console
        console.error(error);
        result.errors.push(error);
      }
    }

    // eslint-disable-next-line no-console
    console.log(
      `[Club Sauna Evaluator] Complete: ${result.evaluated} evaluated, ${result.cancelled} cancelled, ${result.converted} converted, ${result.proceeded} proceeded`
    );

    return result;
  } catch (err) {
    const error = `Club Sauna evaluation failed: ${
      err instanceof Error ? err.message : 'Unknown error'
    }`;
    // eslint-disable-next-line no-console
    console.error(error);
    result.errors.push(error);
    return result;
  }
}

/**
 * Schedule the next run at 20:00 (8 PM)
 */
export function scheduleNextRun(): number {
  const now = new Date();
  const today20 = new Date(now);
  today20.setHours(20, 0, 0, 0);

  let nextRun: Date;

  // If it's already past 20:00 today, schedule for tomorrow at 20:00
  if (now >= today20) {
    nextRun = new Date(today20);
    nextRun.setDate(nextRun.getDate() + 1);
  } else {
    nextRun = today20;
  }

  const msUntilRun = nextRun.getTime() - now.getTime();

  // eslint-disable-next-line no-console
  console.log(
    `[Club Sauna Evaluator] Next run scheduled in ${Math.round(msUntilRun / 1000 / 60)} minutes (${nextRun.toLocaleString()})`
  );

  return msUntilRun;
}

// Self-executing worker setup
if (typeof self !== 'undefined' && self.addEventListener) {
  // eslint-disable-next-line no-console
  console.log('[Club Sauna Evaluator] Worker initialized');

  // Listen for messages from main thread
  self.addEventListener('message', async (event) => {
    const { type } = event.data;

    if (type === 'RUN_NOW') {
      // eslint-disable-next-line no-console
      console.log('[Club Sauna Evaluator] Manual run triggered');
      const result = await evaluateClubSaunas();
      self.postMessage({ type: 'COMPLETE', result });
    } else if (type === 'SCHEDULE') {
      const delay = scheduleNextRun();
      setTimeout(async () => {
        const result = await evaluateClubSaunas();
        self.postMessage({ type: 'COMPLETE', result });

        // Schedule next run
        self.postMessage({ type: 'SCHEDULE' });
      }, delay);
    }
  });

  // Initial schedule
  const delay = scheduleNextRun();
  setTimeout(async () => {
    const result = await evaluateClubSaunas();
    self.postMessage({ type: 'COMPLETE', result });

    // Schedule next run
    self.postMessage({ type: 'SCHEDULE' });
  }, delay);
}
