/**
 * Club Sauna Evaluator Worker
 *
 * Runs daily at 20:00 (8 PM) local time on Island Device
 *
 * Purpose:
 * - Evaluates today's auto-generated Club Sauna reservations
 * - If < 3 boats registered: Cancel shared reservation and convert participants to individual reservations
 * - If >= 3 boats: Let shared reservation proceed as planned
 *
 * This worker operates COMPLETELY OFFLINE on the Island Device
 */

import { db } from '@/db/schema'
import type { LocalReservation } from '@/types'

const MINIMUM_PARTICIPANTS = 3

interface EvaluationResult {
  evaluated: number
  cancelled: number
  converted: number
  proceeded: number
  errors: string[]
}

/**
 * Evaluate and process Club Sauna reservations for today
 */
export async function evaluateClubSaunas(): Promise<EvaluationResult> {
  const result: EvaluationResult = {
    evaluated: 0,
    cancelled: 0,
    converted: 0,
    proceeded: 0,
    errors: [],
  }

  try {
    const today = new Date()
    today.setHours(0, 0, 0, 0)

    console.log('[Club Sauna Evaluator] Starting evaluation for today')

    // Get all auto-generated Club Sauna reservations for today
    const clubSaunas = await db.sharedReservations
      .where('[date+isAutoGenerated]')
      .equals([today.toISOString(), 1])
      .toArray()

    console.log(`[Club Sauna Evaluator] Found ${clubSaunas.length} Club Saunas to evaluate`)

    for (const clubSauna of clubSaunas) {
      try {
        result.evaluated++

        // Get participants
        const participants = await db.sharedParticipants
          .where('sharedReservationId')
          .equals(clubSauna.id)
          .toArray()

        const participantCount = participants.length

        console.log(
          `[Club Sauna Evaluator] Club Sauna ${clubSauna.id}: ${participantCount} participants`
        )

        // Decision point: < 3 boats = cancel and convert
        if (participantCount < MINIMUM_PARTICIPANTS) {
          console.log(
            `[Club Sauna Evaluator] Cancelling (${participantCount} < ${MINIMUM_PARTICIPANTS})`
          )

          // Cancel the shared reservation
          await db.sharedReservations.update(clubSauna.id, {
            autoCancelledAt: new Date(),
            syncStatus: 'pending',
          } as any)

          // Add cancellation to sync queue
          await db.syncQueue.add({
            timestamp: new Date(),
            entityType: 'shared_reservation',
            entityId: clubSauna.id,
            operation: 'update',
            data: { autoCancelledAt: new Date() },
            syncStatus: 'pending',
          } as any)

          result.cancelled++

          // Convert participants to individual reservations
          for (const participant of participants) {
            try {
              // Get boat info
              const boat = await db.boats.get(participant.boatId)
              if (!boat) {
                throw new Error(`Boat ${participant.boatId} not found`)
              }

              // Get sauna info
              const sauna = await db.saunas.get(clubSauna.saunaId)
              if (!sauna) {
                throw new Error(`Sauna ${clubSauna.saunaId} not found`)
              }

              // Parse start time
              const [hours, minutes] = clubSauna.startTime.split(':').map(Number)
              const startTime = new Date(today)
              startTime.setHours(hours, minutes, 0, 0)

              const endTime = new Date(startTime)
              endTime.setHours(startTime.getHours() + 1)

              // Create individual reservation
              const reservation: Partial<LocalReservation> = {
                id: crypto.randomUUID(),
                saunaId: clubSauna.saunaId,
                boatId: participant.boatId,
                startTime: startTime.toISOString(),
                endTime: endTime.toISOString(),
                adults: participant.adults,
                kids: participant.kids,
                status: 'ACTIVE',
                createdAt: new Date().toISOString(),
                syncStatus: 'pending',
              }

              await db.reservations.add(reservation as any)

              // Add to sync queue
              await db.syncQueue.add({
                timestamp: new Date(),
                entityType: 'reservation',
                entityId: reservation.id!,
                operation: 'create',
                data: reservation,
                syncStatus: 'pending',
              } as any)

              // Remove from shared participants
              await db.sharedParticipants.delete(participant.id)

              console.log(
                `[Club Sauna Evaluator] Converted boat ${boat.name} to individual reservation`
              )
              result.converted++
            } catch (err) {
              const error = `Failed to convert participant ${participant.id}: ${
                err instanceof Error ? err.message : 'Unknown error'
              }`
              console.error(error)
              result.errors.push(error)
            }
          }

          // Mark shared reservation as converted
          await db.sharedReservations.update(clubSauna.id, {
            convertedToIndividual: true,
            syncStatus: 'pending',
          } as any)
        } else {
          console.log(
            `[Club Sauna Evaluator] Proceeding (${participantCount} >= ${MINIMUM_PARTICIPANTS})`
          )
          result.proceeded++
        }
      } catch (err) {
        const error = `Failed to evaluate Club Sauna ${clubSauna.id}: ${
          err instanceof Error ? err.message : 'Unknown error'
        }`
        console.error(error)
        result.errors.push(error)
      }
    }

    console.log(
      `[Club Sauna Evaluator] Complete: ${result.evaluated} evaluated, ${result.cancelled} cancelled, ${result.converted} converted, ${result.proceeded} proceeded`
    )

    return result
  } catch (err) {
    const error = `Club Sauna evaluation failed: ${
      err instanceof Error ? err.message : 'Unknown error'
    }`
    console.error(error)
    result.errors.push(error)
    return result
  }
}

/**
 * Schedule the next run at 20:00 (8 PM)
 */
export function scheduleNextRun(): number {
  const now = new Date()
  const today20 = new Date(now)
  today20.setHours(20, 0, 0, 0)

  let nextRun: Date

  // If it's already past 20:00 today, schedule for tomorrow at 20:00
  if (now >= today20) {
    nextRun = new Date(today20)
    nextRun.setDate(nextRun.getDate() + 1)
  } else {
    nextRun = today20
  }

  const msUntilRun = nextRun.getTime() - now.getTime()

  console.log(
    `[Club Sauna Evaluator] Next run scheduled in ${Math.round(msUntilRun / 1000 / 60)} minutes (${nextRun.toLocaleString()})`
  )

  return msUntilRun
}

// Self-executing worker setup
if (typeof self !== 'undefined' && self.addEventListener) {
  console.log('[Club Sauna Evaluator] Worker initialized')

  // Listen for messages from main thread
  self.addEventListener('message', async (event) => {
    const { type } = event.data

    if (type === 'RUN_NOW') {
      console.log('[Club Sauna Evaluator] Manual run triggered')
      const result = await evaluateClubSaunas()
      self.postMessage({ type: 'COMPLETE', result })
    } else if (type === 'SCHEDULE') {
      const delay = scheduleNextRun()
      setTimeout(async () => {
        const result = await evaluateClubSaunas()
        self.postMessage({ type: 'COMPLETE', result })

        // Schedule next run
        self.postMessage({ type: 'SCHEDULE' })
      }, delay)
    }
  })

  // Initial schedule
  const delay = scheduleNextRun()
  setTimeout(async () => {
    const result = await evaluateClubSaunas()
    self.postMessage({ type: 'COMPLETE', result })

    // Schedule next run
    self.postMessage({ type: 'SCHEDULE' })
  }, delay)
}
