/**
 * Club Sauna Generator Worker
 *
 * Runs daily at midnight (00:00) local time on Island Device
 *
 * Purpose:
 * - Automatically creates "Club Sauna" shared reservations during peak season
 * - High Season: Every day in June, July, August
 * - Shoulder Season: Every Friday/Saturday in May, September
 *
 * Default Schedule:
 * - Women: 21:00-22:00
 * - Men: 22:00-23:00
 *
 * This worker operates COMPLETELY OFFLINE on the Island Device
 */

import { db } from '@/db/schema'
import type { LocalSharedReservation } from '@/types'

// Peak season configuration
const HIGH_SEASON_MONTHS = [5, 6, 7] // June, July, August (0-indexed)
const SHOULDER_SEASON_MONTHS = [4, 8] // May, September (0-indexed)
const SHOULDER_SEASON_DAYS = [5, 6] // Friday=5, Saturday=6

// Default Club Sauna schedule
const DEFAULT_START_TIME = '21:00'
const DEFAULT_WOMEN_DURATION = 1 // hours
const DEFAULT_MEN_DURATION = 1 // hours
const DEFAULT_GENDER_ORDER = 'FEMALES_FIRST' as const

interface ClubSaunaConfig {
  shouldCreate: boolean
  reason: string
}

/**
 * Check if today is eligible for Club Sauna creation
 */
function shouldCreateClubSauna(date: Date): ClubSaunaConfig {
  const month = date.getMonth() // 0-indexed
  const dayOfWeek = date.getDay() // 0=Sunday, 6=Saturday

  // High season: Every day in June, July, August
  if (HIGH_SEASON_MONTHS.includes(month)) {
    return {
      shouldCreate: true,
      reason: 'High season (Jun-Aug)',
    }
  }

  // Shoulder season: Friday/Saturday in May, September
  if (SHOULDER_SEASON_MONTHS.includes(month) && SHOULDER_SEASON_DAYS.includes(dayOfWeek)) {
    return {
      shouldCreate: true,
      reason: 'Shoulder season weekend (May/Sep Fri-Sat)',
    }
  }

  return {
    shouldCreate: false,
    reason: 'Outside peak season',
  }
}

/**
 * Generate Club Sauna reservations for eligible saunas
 */
export async function generateClubSaunas(): Promise<{
  created: number
  skipped: number
  errors: string[]
}> {
  const result = {
    created: 0,
    skipped: 0,
    errors: [] as string[],
  }

  try {
    const today = new Date()
    today.setHours(0, 0, 0, 0)

    // Check if we should create Club Sauna today
    const config = shouldCreateClubSauna(today)

    if (!config.shouldCreate) {
      console.log(`[Club Sauna Generator] Skipping: ${config.reason}`)
      return result
    }

    console.log(`[Club Sauna Generator] Creating Club Saunas: ${config.reason}`)

    // Get all saunas with auto Club Sauna enabled
    const saunas = await db.saunas
      .where('autoClubSaunaEnabled')
      .equals(1) // Dexie uses 1 for true
      .toArray()

    console.log(`[Club Sauna Generator] Found ${saunas.length} eligible saunas`)

    for (const sauna of saunas) {
      try {
        // Check if Club Sauna already exists for today
        const existing = await db.sharedReservations
          .where('[saunaId+date+isAutoGenerated]')
          .equals([sauna.id, today.toISOString(), 1])
          .first()

        if (existing) {
          console.log(`[Club Sauna Generator] Already exists for sauna ${sauna.name}`)
          result.skipped++
          continue
        }

        // Create Club Sauna shared reservation
        const clubSauna: Partial<LocalSharedReservation> = {
          id: crypto.randomUUID(),
          saunaId: sauna.id,
          date: today.toISOString(),
          startTime: DEFAULT_START_TIME,
          malesDurationHours: DEFAULT_MEN_DURATION,
          femalesDurationHours: DEFAULT_WOMEN_DURATION,
          genderOrder: DEFAULT_GENDER_ORDER,
          name: 'Club Sauna',
          description: `Automatic ${config.reason}`,
          isAutoGenerated: true,
          autoCancelledAt: undefined,
          convertedToIndividual: false,
          // createdAt will be auto-set by Dexie
          syncStatus: 'pending',
        }

        await db.sharedReservations.add(clubSauna as any)

        // Add to sync queue
        await db.syncQueue.add({
          timestamp: new Date(),
          entityType: 'shared_reservation',
          entityId: clubSauna.id!,
          operation: 'create',
          data: clubSauna,
          syncStatus: 'pending',
        } as any)

        console.log(`[Club Sauna Generator] Created for sauna ${sauna.name}`)
        result.created++
      } catch (err) {
        const error = `Failed to create Club Sauna for ${sauna.name}: ${err instanceof Error ? err.message : 'Unknown error'}`
        console.error(error)
        result.errors.push(error)
      }
    }

    console.log(`[Club Sauna Generator] Complete: ${result.created} created, ${result.skipped} skipped`)

    return result
  } catch (err) {
    const error = `Club Sauna generation failed: ${err instanceof Error ? err.message : 'Unknown error'}`
    console.error(error)
    result.errors.push(error)
    return result
  }
}

/**
 * Schedule the next run at midnight
 */
export function scheduleNextRun(): number {
  const now = new Date()
  const tomorrow = new Date(now)
  tomorrow.setDate(tomorrow.getDate() + 1)
  tomorrow.setHours(0, 0, 0, 0)

  const msUntilMidnight = tomorrow.getTime() - now.getTime()

  console.log(`[Club Sauna Generator] Next run scheduled in ${Math.round(msUntilMidnight / 1000 / 60)} minutes`)

  return msUntilMidnight
}

// Self-executing worker setup
if (typeof self !== 'undefined' && self.addEventListener) {
  console.log('[Club Sauna Generator] Worker initialized')

  // Listen for messages from main thread
  self.addEventListener('message', async (event) => {
    const { type } = event.data

    if (type === 'RUN_NOW') {
      console.log('[Club Sauna Generator] Manual run triggered')
      const result = await generateClubSaunas()
      self.postMessage({ type: 'COMPLETE', result })
    } else if (type === 'SCHEDULE') {
      const delay = scheduleNextRun()
      setTimeout(async () => {
        const result = await generateClubSaunas()
        self.postMessage({ type: 'COMPLETE', result })

        // Schedule next run
        self.postMessage({ type: 'SCHEDULE' })
      }, delay)
    }
  })

  // Initial schedule
  const delay = scheduleNextRun()
  setTimeout(async () => {
    const result = await generateClubSaunas()
    self.postMessage({ type: 'COMPLETE', result })

    // Schedule next run
    self.postMessage({ type: 'SCHEDULE' })
  }, delay)
}
